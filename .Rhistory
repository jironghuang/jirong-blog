textplot(tstats[1:15,,drop=FALSE],show.colnames=FALSE,halign='left')
## ----TSTATS2,echo=FALSE,cache=FALSE--------------------------------------
textplot(tstats[16:30,,drop=FALSE],show.colnames=FALSE,halign='left')
## ------------------------------------------------------------------------
ob <- getOrderBook(qs.strategy)
class(ob)
names(ob)
names(ob$qsFaber)
names(ob$qsFaber$SPY)
## ----echo=FALSE----------------------------------------------------------
options(width=110)
## ----size='tiny'---------------------------------------------------------
ob$qsFaber$SPY[,1:5]
## ----echo=FALSE----------------------------------------------------------
options(width=81)
## ----echo=FALSE----------------------------------------------------------
options(width=110)
## ----size='tiny'---------------------------------------------------------
ob$qsFaber$SPY[,6:11]
## ----echo=FALSE----------------------------------------------------------
options(width=81)
## ----echo=FALSE----------------------------------------------------------
options(width=100)
## ----size='tiny'---------------------------------------------------------
perTradeStats(qs.strategy)
## ----echo=FALSE----------------------------------------------------------
options(width=81)
## ----FABERMAE,cache=FALSE------------------------------------------------
chart.ME(Portfolio=qs.strategy, Symbol='SPY', type='MAE', scale='percent')
## ----FABERMFE,cache=FALSE------------------------------------------------
chart.ME(Portfolio=qs.strategy, Symbol='SPY', type='MFE', scale='percent')
## ----echo=FALSE----------------------------------------------------------
options(width=105)
## ----ACCTSUM,cache=FALSE,size='tiny'-------------------------------------
a <- getAccount(qs.strategy)
last(a$summary,5)
library(lattice)
xyplot(a$summary,type="h",col=4)
## ----echo=FALSE----------------------------------------------------------
options(width=81)
## ------------------------------------------------------------------------
equity <- a$summary$End.Eq
## ----EQCURVE,cache=FALSE-------------------------------------------------
plot(equity,main="Faber Strategy Equity Curve")
## ------------------------------------------------------------------------
ret <- Return.calculate(equity,method="log")
## ----PERFSUM,cache=FALSE-------------------------------------------------
charts.PerformanceSummary(ret, colorset = bluefocus,
main="Faber Strategy Performance")
#Create an arima garch function
#Create another data-frame starting from windowlength + 1 onwards
#Then use apply function to return the information
#Parallelize this-->http://dept.stat.lsa.umich.edu/~jerrick/courses/stat701/notes/parallel.html
#Input
# rolling window
# d,start_index - 1
# Import the necessary libraries
# Parallelize this if got time
library(quantmod)
library(lattice)
library(timeSeries)
library(rugarch)
library(parallel)
ticker = "GLD"   #this could be changed to a command line argument
stock = get(getSymbols(ticker, from="1950-01-01"))
spReturns = diff(log(Cl(stock)))
spReturns[as.character(head(index(Cl(stock)),1))] = 0   #Change the first returns to NA
arima_garch = function(d,windowLength){
#to see the freaking progress
print(d)
# Obtain the S&P500 rolling window for this day
#Using 500 as data points as inputs-->May not make sense to use 1st data point as input
spReturnsOffset = spReturns[(1+d):(windowLength+d)]
# Fit the ARIMA model
final.aic <- Inf
final.order <- c(0,0,0)
for (p in 0:5) for (q in 0:5) {
if ( p == 0 && q == 0) {
next
}
arimaFit = tryCatch( arima(spReturnsOffset, order=c(p, 0, q)),
error=function( err ) FALSE,
warning=function( err ) FALSE )
if( !is.logical( arimaFit ) ) {
current.aic <- AIC(arimaFit)
if (current.aic < final.aic) {
final.aic <- current.aic
final.order <- c(p, 0, q)
final.arima <- arima(spReturnsOffset, order=final.order)
}
} else {
next
}
}
# Specify and fit the GARCH model
spec = ugarchspec(
variance.model=list(garchOrder=c(1,1)),
mean.model=list(armaOrder=c(final.order[1], final.order[3]), include.mean=T),
distribution.model="sged"
)
fit = tryCatch(
ugarchfit(
spec, spReturnsOffset, solver = 'hybrid'
), error=function(e) e, warning=function(w) w
)
# If the GARCH model does not converge, set the direction to "long" else
# choose the correct forecast direction based on the returns prediction
# Output the results to the screen and the forecasts vector
if(is(fit, "warning")) {
#This is the non-converged option. Probably follow the
# forecasts[d+1] = paste(index(spReturnsOffset[windowLength]), 1, sep=",")   #edit this part to remain with previous forecast
# print(paste(index(spReturnsOffset[windowLength]), 1, sep=","))
return("warning")
} else {
fore = ugarchforecast(fit, n.ahead=1)     #1 step look ahead forecast
ind = fore@forecast$seriesFor
# forecasts[d+1] = paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=",")  #at d=0, 500th point. d = 1 is 501st pt
# print(paste(colnames(ind), ifelse(ind[1] < 0, -1, 1), sep=","))
return(ind[1])
}
}
#example of function returning forecasts value
# windowLength = 500
# foreLength = length(spReturns) - windowLength
# forecasts <- vector(mode="character", length=foreLength)
# for (d in 0:foreLength) {
#forecasts for x+1th row to last_row-500 to last row-1
#uses 1st row to 400th row for 401th row
# arima_garch(0,400)
wl = 400
#wl+1th row onwards
# a = mapply(arima_garch,d = 0:nrow(GLD)-wl,windowLength = wl)   #to return the whole series. from wl+1 to nrow(stock)-wl
# a = mapply(arima_garch,d = 0:100,windowLength = wl)
a = mcmapply(arima_garch,d = 0:10,windowLength = wl)
a
##http://www.quintuitive.com/2015/06/21/trading-moving-averages-with-less-whipsaws/
#sectors
# http://www.sectorspdr.com/sectorspdr/
#http://www.sectorspdr.com/sectorspdr/tools/sector-tracker
#think of how to build an annualized returns backtest
#After lag the signal by 1 day, the strategy crumbles
# S&P 500 Index		+2.72%
# Consumer Discretionary (XLY)		+2.95%
# Consumer Staples (XLP)		+1.44%
# Energy (XLE)		+1.78%
# Financials (XLF)		+3.28%
# Health Care (XLV)		+2.07%
# Industrials (XLI)		+2.42%
# Materials (XLB)		+2.11%
# Real Estate (XLRE)		+1.36%
# Technology (XLK)		+3.80%
# Utilities (XLU)		+1.04%
library(quantmod)
library(ggplot2)
library(PerformanceAnalytics)
library(tidyr)
library(dplyr)
library(tibble)
# Download data
# ticker = "^STI"
ticker = "XLK"
stock = getSymbols(ticker,from="1900-01-01",auto.assign=F)
names(stock) = c("open","high","low","close","volume","adj_close")
#Subset stock
stock = subset(stock,!is.na(stock$adj_close))
# Compute the returns
stock$rets = ROC(Cl(stock),type="discrete")
stock$index = 1:nrow(stock)
# Compute the adjusted returns-->Need to lag if not useful
stock$adj.rets_current = stock$rets/sqrt(runSum(stock$rets * stock$rets,10)/9)
# stock$adj.rets = lag(stock$adj.rets_current)
stock$adj.rets = stock$adj.rets_current
# The moving average
stock$sma = runMean(stock$adj.rets,n=200)
# The standard deviation
stock$stddev = sqrt(runSum(stock$adj.rets * stock$adj.rets,200)/199)
# Long trades are entered when the average turns positive
stock$upper.band = 0.0
# Long trades are closed when the average return goes below -0.05 standard deviations
stock$lower.band = -0.05*stock$stddev
#subset data with MA
stock = subset(stock,!is.na(stock$sma))
##################################Executing the trade#############################
stock$signal = ifelse(stock$sma > stock$upper.band,1,0)
stock$signal = ifelse(stock$sma < stock$lower.band,-1,stock$signal)
#Test sensitivity
stock$signal = lag(stock$signal);stock$signal[1] = 0
# table(stock$signal)
#Backtest
stock$strat_returns = stock$rets * stock$signal
stock$portfolio = NA
stock$portfolio[1] = 100 * (1+stock$strat_returns[1])
stock$portfolio = exp(cumsum(stock$strat_returns))
# for(i in 2:nrow(stock)){
#   stock$portfolio[i] = as.numeric(stock$portfolio[i-1]) * as.numeric((1+stock$strat_returns[i]))
# }
#counterfactual portfolio
stock$benchmark = exp(cumsum(stock$rets))
# stock$benchmark = NA
# stock$benchmark[1] = 100
#
# for(i in 2:nrow(stock)){
#   stock$benchmark[i] = as.numeric(stock$benchmark[i-1]) * as.numeric((1+stock$ret[i]))
# }
#Strategy performance-->Create an excel workbook?
plot(stock$portfolio)
table.Drawdowns(stock$strat_returns, top=10)
table.DownsideRisk(stock$strat_returns)
table.AnnualizedReturns(stock$strat_returns)
charts.PerformanceSummary(stock$strat_returns)
#Fixed bet strategy
stock$fix_ret = 100*stock$strat_returns
stock$cum_sum = cumsum(stock$fix_ret)
plot(stock$cum_sum)
#Benchmark cumulative perf
plot(stock$benchmark)
table.Drawdowns(stock$rets, top=10)
table.DownsideRisk(stock$rets)
table.AnnualizedReturns(stock$rets)
charts.PerformanceSummary(stock$rets)
#Fixed bet strategy
stock$fix_ret_benchmark = 100*stock$rets
stock$cum_sum_benchmark = cumsum(stock$fix_ret_benchmark)
plot(stock$cum_sum_benchmark)
#Calculate the turnover
stock$churn = 0
for(i in 2:nrow(stock)){
if((as.numeric(stock$signal[i]) == 1) & (as.numeric(stock$signal[i-1]) == 0)){
stock$churn[i] = 1
}else if ((as.numeric(stock$signal[i]) == 0) & (as.numeric(stock$signal[i-1]) == 1)){
stock$churn[i] = 1
}else if((as.numeric(stock$signal[i]) == -1) & (as.numeric(stock$signal[i-1]) == 0)){
stock$churn[i] = 1
}else if((as.numeric(stock$signal[i]) == 0) & (as.numeric(stock$signal[i-1]) == -1)){
stock$churn[i] = 1
}else if((as.numeric(stock$signal[i]) == -1) & (as.numeric(stock$signal[i-1]) == 1)){
stock$churn[i] = 1
}else if((as.numeric(stock$signal[i]) == 1) & (as.numeric(stock$signal[i-1]) == -1)){
stock$churn[i] = 1
}
}
sum(stock$churn)
#Average loss in dollars per signal: Long and short strategy
#Stake is 100 dollars per trade
as.tibble(stock) %>%
group_by(signal) %>%
summarize(mean = mean(fix_ret))
charts.PerformanceSummary(cbind(stock$strat_returns,stock$rets))
rm(list = ls())
library(quantmod)
library(ggplot2)
library(PerformanceAnalytics)
library(tidyr)
library(dplyr)
library(tibble)
# Download data
ticker1 = "GLD"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker2 = "SPY"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker2 = "AGG"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
plot(SPY[,6])
library(quantmod)
library(ggplot2)
library(PerformanceAnalytics)
library(tidyr)
library(dplyr)
library(tibble)
# Download data
ticker1 = "GLD"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker2 = "SPY"
stock2 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker3 = "AGG"
stock3 = getSymbols(ticker3,from="1900-01-01",auto.assign=F)
names(stock3) = c("open","high","low","close","volume","adj_close")
plot(stock3[,6])
plot(stock2[,6])
plot(stock1[,6])
library(quantmod)
library(ggplot2)
library(PerformanceAnalytics)
library(tidyr)
library(dplyr)
library(tibble)
# Download data
ticker1 = "GLD"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker2 = "SPY"
stock2 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker3 = "AGG"
stock3 = getSymbols(ticker3,from="1900-01-01",auto.assign=F)
names(stock3) = c("open","high","low","close","volume","adj_close")
View(stock1)
last(stock1, 2)
library(blogdown)
setwd("/home/jirong/Desktop/github/jirong-blog")
blogdown::serve_site()
shiny::runApp('~/Dropbox/index_shiny')
install.packages("extrafont")
runApp('~/Dropbox/index_shiny')
runApp('~/Dropbox/index_shiny')
runApp('~/Dropbox/index_shiny')
runApp('~/Dropbox/index_shiny')
#Cant use stat_smooth function in scatterplot
# https://rviews.rstudio.com/2017/02/03/reproducible-finance-with-r-sector-correlations-shiny-app/
library("ggplot2")
library("dplyr")
library("reshape2")
library("quantmod")
library("grid")
library("shiny")
library("extrafont")
ticker = "SPY"
runApp('~/Dropbox/index_shiny')
start <- as.Date("1950-01-01")
end <- as.Date("2020-10-01")
getSymbols(ticker,from = start, to = end)
stock_price = as.data.frame(get(ticker))
#create a loop and lag x times
lag_days = 251
# stk_price = function(lag_days){
for(i in 1:lag_days) { #lag_days = 260
# as.data.frame(lag(stock_price,i))
a = assign(paste("lag",i,sep=""),as.data.frame(lag(stock_price[,4],i)))
names(a) = paste("lag",i)
stock_price = cbind(stock_price,a)
rm(list = ls()[grepl("lag", ls())]) #remove lags from each iteration, ls refers to list of dataframes
}
nrows = dim(a)[1]
#Create a % of 52 week high, 52 week low
#% 52 week high
max_52weeks = as.data.frame(apply(stock_price[,-c(1,2,3,5)],1,max))
lower_52weekhigh = (stock_price[,4] -  max_52weeks)/max_52weeks
names(lower_52weekhigh)[1] = "col1"
#% off 52 week low
min_52weeks = as.data.frame(apply(stock_price[,-c(1,2,3,5)],1,min))
higher_52weeklow = (stock_price[,4] -  min_52weeks)/min_52weeks
names(higher_52weeklow )[1] = "col1"
#Create a lag of 1,3,5 years ago
leadprice = as.data.frame(lead(stock_price[,4],251))
names(leadprice)[1] = "lead1yr"
leadprice$lead2yr = lead(stock_price[,4],502)
leadprice$lead3yr = lead(stock_price[,4],753)
#Compute returns
returns= as.data.frame((leadprice$lead1yr -  stock_price[,4])/stock_price[,4])
names(returns)[1] = "returns_1yr"
returns$returns_2yr = (leadprice$lead2yr -  stock_price[,4])/stock_price[,4]
returns$returns_3yr = (leadprice$lead3yr -  stock_price[,4])/stock_price[,4]
#Look at returns-%52 week high scatterplot
dat = cbind(row.names(stock_price),lower_52weekhigh,higher_52weeklow,returns)
names(dat) = c("Date","lower_52weekhigh","higher_52weeklow", "returns_1yr","returns_2yr","returns_3yr")
dat$Date = as.Date(dat$Date)
dat = subset(dat,!is.na(dat$lower_52weekhigh))
dat = subset(dat,!is.na(dat$higher_52weeklow))
dat$Date = as.Date(dat$Date)
# p = hist(dat$returns_1yr)
myBreaks <- function(x){
breaks <- c(min(x),median(x),max(x))
breaks = quantile(x, c(0, 0.2,0.4,0.6,0.8,1))
attr(breaks,"labels") <- as.Date(breaks, origin="1970-01-01")
names(breaks) <- attr(breaks,"labels")
return(breaks)
}
# # dat = subset(dat,!is.na(dat$Date))
dat1 = subset(dat,!is.na(dat$returns_1yr))
yr1_high = ggplot(dat1,aes(lower_52weekhigh,returns_1yr,colour=as.integer(Date))) + geom_point(alpha = 0.6) +
scale_colour_gradientn(colours = rainbow(5), breaks=myBreaks) + ggtitle("1yr returns vs. Change from 52 week high")+xlab("Change from 52 week high")+ylab("Returns 1 year later")
#something wrong with non parametric regression
yr1_high = yr1_high+geom_smooth(method = "lm", se = TRUE)
yr1_high = yr1_high +theme(axis.text=element_text(size=12),axis.title=element_text(size=14,face="bold"))+
theme(plot.title=element_text(face="bold", size=12)) + labs(color="date")
dat2 = subset(dat,!is.na(dat$returns_2yr))
yr2_high = ggplot(dat2,aes(lower_52weekhigh,returns_2yr,colour=as.integer(Date))) + geom_point(alpha = 0.6) +
scale_colour_gradientn(colours = rainbow(7), breaks=myBreaks) + ggtitle("2yr returns vs. Change from 52 week high")+xlab("Change from 52 week high")+ylab("Returns 2 year later")
yr2_high = yr2_high+geom_smooth(method = "lm", se = TRUE)
yr2_high = yr2_high +theme(axis.text=element_text(size=12),axis.title=element_text(size=14,face="bold"))+
theme(plot.title=element_text(face="bold", size=12)) + labs(color="date")
# yr2_high
# # yr2 = lm(dat$returns_2yr~ dat$lower_52weekhigh)
# # yr2$coefficients[2]*(-0.03) + yr2$coefficients[1]
#
dat3 = subset(dat,!is.na(dat$returns_3yr))
yr3_high = ggplot(dat3,aes(lower_52weekhigh,returns_3yr,colour=as.integer(Date))) + geom_point(alpha = 0.6) +
scale_colour_gradientn(colours = rainbow(7), breaks=myBreaks) + ggtitle("3yr returns vs. Change from 52 week high")+xlab("Change from 52 week high")+ylab("Returns 3 year later")
yr3_high = yr3_high+geom_smooth(method = "lm", se = TRUE)
yr3_high = yr3_high +theme(axis.text=element_text(size=12),axis.title=element_text(size=14,face="bold"))+
theme(plot.title=element_text(face="bold", size=12)) + labs(color="date")
# yr3_high
# yr3 = lm(dat$returns_3yr~ dat$lower_52weekhigh)
# yr3$coefficients[2]*(-0.03) + yr3$coefficients[1]
#Plot out the numbers
l = lower_52weekhigh$col1[nrow(lower_52weekhigh)]
yr1 = lm(dat1$returns_1yr~ dat1$lower_52weekhigh)
yr1
yr1 = yr1$coefficients[2]*(l) + yr1$coefficients[1]
yr1
yr1_high
yr1_high = ggplot(dat1,aes(lower_52weekhigh,returns_1yr,colour=as.integer(Date))) + geom_point(alpha = 0.6) +
scale_colour_gradientn(colours = rainbow(5), breaks=myBreaks) + ggtitle("1yr returns vs. Change from 52 week high")+xlab("Change from 52 week high")+ylab("Returns 1 year later")
yr1_high
#something wrong with non parametric regression
yr1_high = yr1_high + geom_smooth(method = "lm", se = TRUE)
yr1_high
yr1
yr1$coefficients[2]*(l)
yr1$coefficients[2]
#Plot out the numbers
l = lower_52weekhigh$col1[nrow(lower_52weekhigh)]
yr1 = lm(dat1$returns_1yr~ dat1$lower_52weekhigh)
yr1 = yr1$coefficients[2]*(l) + yr1$coefficients[1]
yr1 = yr1$coefficients[2]*(l) + yr1$coefficients[1]
runApp('~/Dropbox/index_shiny')
View(dat1)
#then use SPY etf for live data going forward
#Cant use stat_smooth function in scatterplot
# https://rviews.rstudio.com/2017/02/03/reproducible-finance-with-r-sector-correlations-shiny-app/
library("ggplot2")
library("dplyr")
library("reshape2")
library("quantmod")
library("grid")
library("shiny")
library("extrafont")
ticker = "SPY"
start <- as.Date("1950-01-01")
end <- as.Date("2020-10-01")
getSymbols(ticker,from = start, to = end)
stock_price = as.data.frame(get(ticker))
# p = hist(stock_price[,4])
#create a loop and lag x times
lag_days = 251
# stk_price = function(lag_days){
for(i in 1:lag_days) { #lag_days = 260
# as.data.frame(lag(stock_price,i))
a = assign(paste("lag",i,sep=""),as.data.frame(lag(stock_price[,4],i)))
names(a) = paste("lag",i)
stock_price = cbind(stock_price,a)
rm(list = ls()[grepl("lag", ls())]) #remove lags from each iteration, ls refers to list of dataframes
}
nrows = dim(a)[1]
#Create a % of 52 week high, 52 week low
#% 52 week high
max_52weeks = as.data.frame(apply(stock_price[,-c(1,2,3,5)],1,max))
lower_52weekhigh = (stock_price[,4] -  max_52weeks)/max_52weeks
names(lower_52weekhigh)[1] = "col1"
View(lower_52weekhigh)
#% off 52 week low
min_52weeks = as.data.frame(apply(stock_price[,-c(1,2,3,5)],1,min))
higher_52weeklow = (stock_price[,4] -  min_52weeks)/min_52weeks
names(higher_52weeklow )[1] = "col1"
#Create a lag of 1,3,5 years ago
leadprice = as.data.frame(lead(stock_price[,4],251))
names(leadprice)[1] = "lead1yr"
leadprice$lead2yr = lead(stock_price[,4],502)
leadprice$lead3yr = lead(stock_price[,4],753)
#Compute returns
returns= as.data.frame((leadprice$lead1yr -  stock_price[,4])/stock_price[,4])
names(returns)[1] = "returns_1yr"
returns$returns_2yr = (leadprice$lead2yr -  stock_price[,4])/stock_price[,4]
returns$returns_3yr = (leadprice$lead3yr -  stock_price[,4])/stock_price[,4]
#Look at returns-%52 week high scatterplot
dat = cbind(row.names(stock_price),lower_52weekhigh,higher_52weeklow,returns)
names(dat) = c("Date","lower_52weekhigh","higher_52weeklow", "returns_1yr","returns_2yr","returns_3yr")
dat$Date = as.Date(dat$Date)
dat = subset(dat,!is.na(dat$lower_52weekhigh))
dat = subset(dat,!is.na(dat$higher_52weeklow))
dat$Date = as.Date(dat$Date)
View(dat)
# p = hist(dat$returns_1yr)
myBreaks <- function(x){
breaks <- c(min(x),median(x),max(x))
breaks = quantile(x, c(0, 0.2,0.4,0.6,0.8,1))
attr(breaks,"labels") <- as.Date(breaks, origin="1970-01-01")
names(breaks) <- attr(breaks,"labels")
return(breaks)
}
# # dat = subset(dat,!is.na(dat$Date))
dat1 = subset(dat,!is.na(dat$returns_1yr))
View(dat1)
yr1_high = ggplot(dat1,aes(lower_52weekhigh,returns_1yr,colour=as.integer(Date))) + geom_point(alpha = 0.6) +
scale_colour_gradientn(colours = rainbow(5), breaks=myBreaks) + ggtitle("1yr returns vs. Change from 52 week high")+xlab("Change from 52 week high")+ylab("Returns 1 year later")
yr1_high
yr1 = lm(dat1$returns_1yr~ dat1$lower_52weekhigh)
yr1
yr1$coefficients[2]
l
#Plot out the numbers
l = lower_52weekhigh$col1[nrow(lower_52weekhigh)]
yr1$coefficients[2]*(l)
yr1$coefficients[1]
yr1 = yr1$coefficients[2]*(l) + yr1$coefficients[1]
yr1
yr2 = lm(dat2$returns_2yr~ dat2$lower_52weekhigh)
# yr1_high
# # yr1 = lm(dat$returns_1yr~ dat$lower_52weekhigh)
# # yr1$coefficients[2]*(-0.03) + yr1$coefficients[1]
#
dat2 = subset(dat,!is.na(dat$returns_2yr))
yr2 = lm(dat2$returns_2yr~ dat2$lower_52weekhigh)
yr2
yr2 = yr2$coefficients[2]*(l) + yr2$coefficients[1]
yr2
l
