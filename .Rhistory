charts.PerformanceSummary(stock$rets)
#Fixed bet strategy
stock$fix_ret_benchmark = 100*stock$rets
stock$cum_sum_benchmark = cumsum(stock$fix_ret_benchmark)
plot(stock$cum_sum_benchmark)
#Calculate the turnover
stock$churn = 0
for(i in 2:nrow(stock)){
if((as.numeric(stock$signal[i]) == 1) & (as.numeric(stock$signal[i-1]) == 0)){
stock$churn[i] = 1
}else if ((as.numeric(stock$signal[i]) == 0) & (as.numeric(stock$signal[i-1]) == 1)){
stock$churn[i] = 1
}else if((as.numeric(stock$signal[i]) == -1) & (as.numeric(stock$signal[i-1]) == 0)){
stock$churn[i] = 1
}else if((as.numeric(stock$signal[i]) == 0) & (as.numeric(stock$signal[i-1]) == -1)){
stock$churn[i] = 1
}else if((as.numeric(stock$signal[i]) == -1) & (as.numeric(stock$signal[i-1]) == 1)){
stock$churn[i] = 1
}else if((as.numeric(stock$signal[i]) == 1) & (as.numeric(stock$signal[i-1]) == -1)){
stock$churn[i] = 1
}
}
sum(stock$churn)
#Average loss in dollars per signal: Long and short strategy
#Stake is 100 dollars per trade
as.tibble(stock) %>%
group_by(signal) %>%
summarize(mean = mean(fix_ret))
charts.PerformanceSummary(cbind(stock$strat_returns,stock$rets))
rm(list = ls())
library(quantmod)
library(ggplot2)
library(PerformanceAnalytics)
library(tidyr)
library(dplyr)
library(tibble)
# Download data
ticker1 = "GLD"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker2 = "SPY"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker2 = "AGG"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
plot(SPY[,6])
library(quantmod)
library(ggplot2)
library(PerformanceAnalytics)
library(tidyr)
library(dplyr)
library(tibble)
# Download data
ticker1 = "GLD"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker2 = "SPY"
stock2 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker3 = "AGG"
stock3 = getSymbols(ticker3,from="1900-01-01",auto.assign=F)
names(stock3) = c("open","high","low","close","volume","adj_close")
plot(stock3[,6])
plot(stock2[,6])
plot(stock1[,6])
library(quantmod)
library(ggplot2)
library(PerformanceAnalytics)
library(tidyr)
library(dplyr)
library(tibble)
# Download data
ticker1 = "GLD"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker2 = "SPY"
stock2 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
ticker3 = "AGG"
stock3 = getSymbols(ticker3,from="1900-01-01",auto.assign=F)
names(stock3) = c("open","high","low","close","volume","adj_close")
View(stock1)
last(stock1, 2)
#Permanent portfolio strategy
#Based on the literature, this is a moderate returns, low volatility strategy.
#Considerably higher sharpe ratio than conventional asset allocation strategies
#https://cssanalytics.wordpress.com/2012/11/01/permanent-portfolio-derivation-and-historical-performance/
#Use an indicator to state the day or month to rebalance
#Idea is to take the total portfolio value and divide by the asset allocation % at the rebalancing date
#In the intermediate period, use the daily returns
library(quantmod)
library(ggplot2)
library(PerformanceAnalytics)
library(tidyr)
library(dplyr)
library(tibble)
# Download data-->Fix the ending date for project section
ticker1 = "GLD"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
stock1 = stock1[,6]
ticker2 = "VT"
stock2 = getSymbols(ticker2,from="1900-01-01",auto.assign=F)
names(stock2) = c("open","high","low","close","volume","adj_close")
stock2 = stock2[,6]
ticker3 = "AGG"
stock3 = getSymbols(ticker3,from="1900-01-01",auto.assign=F)
names(stock3) = c("open","high","low","close","volume","adj_close")
stock3 = stock3[,6]
# Merge the time series and subset NA
#These are the various time series
ticker_list = c("stock1","stock2","stock3")
#read in list. Loop through and assign variable to holder variable. Then assign it to combined list
ticker_all = get(ticker_list[1])
#Merging in the time series
for(i in 2:length(ticker_list)){
ticker_ind = get(ticker_list[i])
ticker_all = merge(ticker_all,ticker_ind)
}
names(ticker_all) = c("stock1","stock2","stock3")
#Assign equal weights to each stream of returns
ticker_all = cbind(ticker_all,rowMeans(ticker_all))
ticker_all = subset(ticker_all,!is.na(ticker_all[,4]))
ticker_all = ticker_all[,-ncol(ticker_all)]
#Identify the period of rebalancing. Show the indexes
rebal_index = data.frame(index = endpoints(ticker_all,on="years")[-1])
# endpoints(ticker_all,on="quarters")
#Merge in the indicator into ticker_all--Can't seem to merge. Will do the inefficient loop
# merge(ticker_all,rebal_index, by = "index", all = T)
ticker_all$rebal = NA
for(i in 1:nrow(rebal_index)){
ticker_all$rebal[rebal_index$index[i]] = 1
}
ticker_all$rebal = ifelse(is.na(ticker_all$rebal),0,ticker_all$rebal)
#Create the returns for each price series
ticker_all$ret1 = ROC(ticker_all[,1])
ticker_all$ret2 = ROC(ticker_all[,2])
ticker_all$ret3 = ROC(ticker_all[,3])
#Initialise value for each stock series, with a total portfolio value
ticker_all$val1 = NA; ticker_all$val1[1] = 100
ticker_all$val2 = NA; ticker_all$val2[1] = 100
ticker_all$val3 = NA; ticker_all$val3[1] = 100
ticker_all$portfolio_val = NA
ticker_all$portfolio_val[1] = rowSums(ticker_all[1,8:10])
#Loop each row and 'compound'. Till it reaches the rebalancing date. Then reset stock value amount in that day. Take the portfolio value in t-1
for(i in 2:nrow(ticker_all)){
if(as.numeric(ticker_all$rebal[i]) == 0){
#During non-rebalancing days
ticker_all$val1[i] = as.numeric(ticker_all$val1[i-1]) * (1 + as.numeric(ticker_all$ret1[i]))
ticker_all$val2[i] = as.numeric(ticker_all$val2[i-1]) * (1 + as.numeric(ticker_all$ret2[i]))
ticker_all$val3[i] = as.numeric(ticker_all$val3[i-1]) * (1 + as.numeric(ticker_all$ret3[i]))
ticker_all$portfolio_val[i] = rowSums(ticker_all[i,8:10])
}else{
#During re-balancing days
ticker_all$val1[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$val2[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$val3[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$portfolio_val[i] = rowSums(ticker_all[i,8:10])
}
}
#Generate the daily portfolio returns
ticker_all$portfolio_ret = ROC(ticker_all[,11])
# rf = rf["2012/2018"]
######################################Study the portfolio returns########################################
#Carry out the portfolio return series
table.Drawdowns(ticker_all$portfolio_ret, top=10)
table.DownsideRisk(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
table.AnnualizedReturns(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
charts.PerformanceSummary(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
#####################################Study the annualized portfolio returns series#######################
#Use the rebal-indicator. Loop through the chunks
# https://www.quantmod.com/documentation/periodReturn.html
# https://rpubs.com/mohammadshadan/288218
# yearly_ret = periodReturn(ticker_all$portfolio_val
#              ,period='yearly',subset='2004::')  # returns years 2003 to present
yearly_ret = periodReturn(ticker_all$portfolio_val
,period='yearly')  # returns years 2003 to present
#Inefficient way to calulate standard deviation. If it've time, I will probably optimize this
split_val = split(ticker_all$portfolio_ret, f = "years")
yearly_ret$annual_sd = sapply(X = split_val, FUN = StdDev) * sqrt(252)
getSymbols('DGS3MO',src = 'FRED')
rf = DGS3MO; rm(DGS3MO)
rf = rf["2004/2018"]
split_val_rf = split(rf$DGS3MO, f = "years")
yearly_ret$annual_rf = sapply(X = split_val_rf, FUN = mean, na.rm = T)/100
yearly_ret$Sharpe = (yearly_ret$yearly.returns - yearly_ret$annual_rf)/yearly_ret$annual_sd
#Permanent portfolio strategy
#Based on the literature, this is a moderate returns, low volatility strategy.
#Considerably higher sharpe ratio than conventional asset allocation strategies
#https://cssanalytics.wordpress.com/2012/11/01/permanent-portfolio-derivation-and-historical-performance/
#Use an indicator to state the day or month to rebalance
#Idea is to take the total portfolio value and divide by the asset allocation % at the rebalancing date
#In the intermediate period, use the daily returns
library(quantmod)
library(ggplot2)
library(PerformanceAnalytics)
library(tidyr)
library(dplyr)
library(tibble)
# Download data-->Fix the ending date for project section
ticker1 = "GLD"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
stock1 = stock1[,6]
ticker2 = "VT"
stock2 = getSymbols(ticker2,from="1900-01-01",auto.assign=F)
names(stock2) = c("open","high","low","close","volume","adj_close")
stock2 = stock2[,6]
ticker3 = "A35.SI"
stock3 = getSymbols(ticker3,from="1900-01-01",auto.assign=F)
names(stock3) = c("open","high","low","close","volume","adj_close")
stock3 = stock3[,6]
# Merge the time series and subset NA
#These are the various time series
ticker_list = c("stock1","stock2","stock3")
#read in list. Loop through and assign variable to holder variable. Then assign it to combined list
ticker_all = get(ticker_list[1])
#Merging in the time series
for(i in 2:length(ticker_list)){
ticker_ind = get(ticker_list[i])
ticker_all = merge(ticker_all,ticker_ind)
}
names(ticker_all) = c("stock1","stock2","stock3")
#Assign equal weights to each stream of returns
ticker_all = cbind(ticker_all,rowMeans(ticker_all))
ticker_all = subset(ticker_all,!is.na(ticker_all[,4]))
ticker_all = ticker_all[,-ncol(ticker_all)]
#Identify the period of rebalancing. Show the indexes
rebal_index = data.frame(index = endpoints(ticker_all,on="years")[-1])
# endpoints(ticker_all,on="quarters")
#Merge in the indicator into ticker_all--Can't seem to merge. Will do the inefficient loop
# merge(ticker_all,rebal_index, by = "index", all = T)
ticker_all$rebal = NA
for(i in 1:nrow(rebal_index)){
ticker_all$rebal[rebal_index$index[i]] = 1
}
ticker_all$rebal = ifelse(is.na(ticker_all$rebal),0,ticker_all$rebal)
#Create the returns for each price series
ticker_all$ret1 = ROC(ticker_all[,1])
ticker_all$ret2 = ROC(ticker_all[,2])
ticker_all$ret3 = ROC(ticker_all[,3])
#Initialise value for each stock series, with a total portfolio value
ticker_all$val1 = NA; ticker_all$val1[1] = 100
ticker_all$val2 = NA; ticker_all$val2[1] = 100
ticker_all$val3 = NA; ticker_all$val3[1] = 100
ticker_all$portfolio_val = NA
ticker_all$portfolio_val[1] = rowSums(ticker_all[1,8:10])
#Loop each row and 'compound'. Till it reaches the rebalancing date. Then reset stock value amount in that day. Take the portfolio value in t-1
for(i in 2:nrow(ticker_all)){
if(as.numeric(ticker_all$rebal[i]) == 0){
#During non-rebalancing days
ticker_all$val1[i] = as.numeric(ticker_all$val1[i-1]) * (1 + as.numeric(ticker_all$ret1[i]))
ticker_all$val2[i] = as.numeric(ticker_all$val2[i-1]) * (1 + as.numeric(ticker_all$ret2[i]))
ticker_all$val3[i] = as.numeric(ticker_all$val3[i-1]) * (1 + as.numeric(ticker_all$ret3[i]))
ticker_all$portfolio_val[i] = rowSums(ticker_all[i,8:10])
}else{
#During re-balancing days
ticker_all$val1[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$val2[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$val3[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$portfolio_val[i] = rowSums(ticker_all[i,8:10])
}
}
#Generate the daily portfolio returns
ticker_all$portfolio_ret = ROC(ticker_all[,11])
# rf = rf["2012/2018"]
######################################Study the portfolio returns########################################
#Carry out the portfolio return series
table.Drawdowns(ticker_all$portfolio_ret, top=10)
table.DownsideRisk(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
table.AnnualizedReturns(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
charts.PerformanceSummary(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
#####################################Study the annualized portfolio returns series#######################
#Use the rebal-indicator. Loop through the chunks
# https://www.quantmod.com/documentation/periodReturn.html
# https://rpubs.com/mohammadshadan/288218
# yearly_ret = periodReturn(ticker_all$portfolio_val
#              ,period='yearly',subset='2004::')  # returns years 2003 to present
yearly_ret = periodReturn(ticker_all$portfolio_val
,period='yearly')  # returns years 2003 to present
#Inefficient way to calulate standard deviation. If it've time, I will probably optimize this
split_val = split(ticker_all$portfolio_ret, f = "years")
yearly_ret$annual_sd = sapply(X = split_val, FUN = StdDev) * sqrt(252)
getSymbols('DGS3MO',src = 'FRED')
rf = DGS3MO; rm(DGS3MO)
rf = rf["2004/2018"]
split_val_rf = split(rf$DGS3MO, f = "years")
yearly_ret$annual_rf = sapply(X = split_val_rf, FUN = mean, na.rm = T)/100
yearly_ret$Sharpe = (yearly_ret$yearly.returns - yearly_ret$annual_rf)/yearly_ret$annual_sd
#Permanent portfolio strategy
#Based on the literature, this is a moderate returns, low volatility strategy.
#Considerably higher sharpe ratio than conventional asset allocation strategies
#https://cssanalytics.wordpress.com/2012/11/01/permanent-portfolio-derivation-and-historical-performance/
#Use an indicator to state the day or month to rebalance
#Idea is to take the total portfolio value and divide by the asset allocation % at the rebalancing date
#In the intermediate period, use the daily returns
library(quantmod)
library(ggplot2)
library(PerformanceAnalytics)
library(tidyr)
library(dplyr)
library(tibble)
# Download data-->Fix the ending date for project section
ticker1 = "GLD"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
stock1 = stock1[,6]
ticker2 = "VT"
stock2 = getSymbols(ticker2,from="1900-01-01",auto.assign=F)
names(stock2) = c("open","high","low","close","volume","adj_close")
stock2 = stock2[,6]
ticker3 = "AGG"
stock3 = getSymbols(ticker3,from="1900-01-01",auto.assign=F)
names(stock3) = c("open","high","low","close","volume","adj_close")
stock3 = stock3[,6]
# Merge the time series and subset NA
#These are the various time series
ticker_list = c("stock1","stock2","stock3")
#read in list. Loop through and assign variable to holder variable. Then assign it to combined list
ticker_all = get(ticker_list[1])
#Merging in the time series
for(i in 2:length(ticker_list)){
ticker_ind = get(ticker_list[i])
ticker_all = merge(ticker_all,ticker_ind)
}
names(ticker_all) = c("stock1","stock2","stock3")
#Assign equal weights to each stream of returns
ticker_all = cbind(ticker_all,rowMeans(ticker_all))
ticker_all = subset(ticker_all,!is.na(ticker_all[,4]))
ticker_all = ticker_all[,-ncol(ticker_all)]
#Identify the period of rebalancing. Show the indexes
rebal_index = data.frame(index = endpoints(ticker_all,on="years")[-1])
# endpoints(ticker_all,on="quarters")
#Merge in the indicator into ticker_all--Can't seem to merge. Will do the inefficient loop
# merge(ticker_all,rebal_index, by = "index", all = T)
ticker_all$rebal = NA
for(i in 1:nrow(rebal_index)){
ticker_all$rebal[rebal_index$index[i]] = 1
}
ticker_all$rebal = ifelse(is.na(ticker_all$rebal),0,ticker_all$rebal)
#Create the returns for each price series
ticker_all$ret1 = ROC(ticker_all[,1])
ticker_all$ret2 = ROC(ticker_all[,2])
ticker_all$ret3 = ROC(ticker_all[,3])
#Initialise value for each stock series, with a total portfolio value
ticker_all$val1 = NA; ticker_all$val1[1] = 100
ticker_all$val2 = NA; ticker_all$val2[1] = 100
ticker_all$val3 = NA; ticker_all$val3[1] = 100
ticker_all$portfolio_val = NA
ticker_all$portfolio_val[1] = rowSums(ticker_all[1,8:10])
#Loop each row and 'compound'. Till it reaches the rebalancing date. Then reset stock value amount in that day. Take the portfolio value in t-1
for(i in 2:nrow(ticker_all)){
if(as.numeric(ticker_all$rebal[i]) == 0){
#During non-rebalancing days
ticker_all$val1[i] = as.numeric(ticker_all$val1[i-1]) * (1 + as.numeric(ticker_all$ret1[i]))
ticker_all$val2[i] = as.numeric(ticker_all$val2[i-1]) * (1 + as.numeric(ticker_all$ret2[i]))
ticker_all$val3[i] = as.numeric(ticker_all$val3[i-1]) * (1 + as.numeric(ticker_all$ret3[i]))
ticker_all$portfolio_val[i] = rowSums(ticker_all[i,8:10])
}else{
#During re-balancing days
ticker_all$val1[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$val2[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$val3[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$portfolio_val[i] = rowSums(ticker_all[i,8:10])
}
}
#Generate the daily portfolio returns
ticker_all$portfolio_ret = ROC(ticker_all[,11])
# rf = rf["2012/2018"]
######################################Study the portfolio returns########################################
#Carry out the portfolio return series
table.Drawdowns(ticker_all$portfolio_ret, top=10)
table.DownsideRisk(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
table.AnnualizedReturns(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
charts.PerformanceSummary(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
#####################################Study the annualized portfolio returns series#######################
#Use the rebal-indicator. Loop through the chunks
# https://www.quantmod.com/documentation/periodReturn.html
# https://rpubs.com/mohammadshadan/288218
# yearly_ret = periodReturn(ticker_all$portfolio_val
#              ,period='yearly',subset='2004::')  # returns years 2003 to present
yearly_ret = periodReturn(ticker_all$portfolio_val
,period='yearly')  # returns years 2003 to present
#Inefficient way to calulate standard deviation. If it've time, I will probably optimize this
split_val = split(ticker_all$portfolio_ret, f = "years")
yearly_ret$annual_sd = sapply(X = split_val, FUN = StdDev) * sqrt(252)
getSymbols('DGS3MO',src = 'FRED')
rf = DGS3MO; rm(DGS3MO)
rf = rf["2004/2018"]
split_val_rf = split(rf$DGS3MO, f = "years")
yearly_ret$annual_rf = sapply(X = split_val_rf, FUN = mean, na.rm = T)/100
yearly_ret$Sharpe = (yearly_ret$yearly.returns - yearly_ret$annual_rf)/yearly_ret$annual_sd
sapply(X = split_val_rf, FUN = mean, na.rm = T)/100
yearly_ret$annual_rf = sapply(X = split_val_rf, FUN = mean, na.rm = T)/100
yearly_ret
rf = rf["2008/2018"]
split_val_rf = split(rf$DGS3MO, f = "years")
yearly_ret$annual_rf = sapply(X = split_val_rf, FUN = mean, na.rm = T)/100
yearly_ret$Sharpe = (yearly_ret$yearly.returns - yearly_ret$annual_rf)/yearly_ret$annual_sd
yearly_ret
yearly_ret$annual_sd
yearly_ret$annual_sd = sapply(X = split_val, FUN = StdDev) * sqrt(252)
yearly_ret
yearly_ret$Sharpe = (yearly_ret$yearly.returns - yearly_ret$annual_rf)/yearly_ret$annual_sd
yearly_ret
#Permanent portfolio strategy
#Based on the literature, this is a moderate returns, low volatility strategy.
#Considerably higher sharpe ratio than conventional asset allocation strategies
#https://cssanalytics.wordpress.com/2012/11/01/permanent-portfolio-derivation-and-historical-performance/
#Use an indicator to state the day or month to rebalance
#Idea is to take the total portfolio value and divide by the asset allocation % at the rebalancing date
#In the intermediate period, use the daily returns
library(quantmod)
library(ggplot2)
library(PerformanceAnalytics)
library(tidyr)
library(dplyr)
library(tibble)
# Download data-->Fix the ending date for project section
ticker1 = "GLD"
stock1 = getSymbols(ticker1,from="1900-01-01",auto.assign=F)
names(stock1) = c("open","high","low","close","volume","adj_close")
stock1 = stock1[,6]
ticker2 = "VT"
stock2 = getSymbols(ticker2,from="1900-01-01",auto.assign=F)
names(stock2) = c("open","high","low","close","volume","adj_close")
stock2 = stock2[,6]
ticker3 = "AGG"
stock3 = getSymbols(ticker3,from="1900-01-01",auto.assign=F)
names(stock3) = c("open","high","low","close","volume","adj_close")
stock3 = stock3[,6]
# Merge the time series and subset NA
#These are the various time series
ticker_list = c("stock1","stock2","stock3")
#read in list. Loop through and assign variable to holder variable. Then assign it to combined list
ticker_all = get(ticker_list[1])
#Merging in the time series
for(i in 2:length(ticker_list)){
ticker_ind = get(ticker_list[i])
ticker_all = merge(ticker_all,ticker_ind)
}
names(ticker_all) = c("stock1","stock2","stock3")
#Assign equal weights to each stream of returns
ticker_all = cbind(ticker_all,rowMeans(ticker_all))
ticker_all = subset(ticker_all,!is.na(ticker_all[,4]))
ticker_all = ticker_all[,-ncol(ticker_all)]
#Identify the period of rebalancing. Show the indexes
rebal_index = data.frame(index = endpoints(ticker_all,on="years")[-1])
# endpoints(ticker_all,on="quarters")
#Merge in the indicator into ticker_all--Can't seem to merge. Will do the inefficient loop
# merge(ticker_all,rebal_index, by = "index", all = T)
ticker_all$rebal = NA
for(i in 1:nrow(rebal_index)){
ticker_all$rebal[rebal_index$index[i]] = 1
}
ticker_all$rebal = ifelse(is.na(ticker_all$rebal),0,ticker_all$rebal)
#Create the returns for each price series
ticker_all$ret1 = ROC(ticker_all[,1])
ticker_all$ret2 = ROC(ticker_all[,2])
ticker_all$ret3 = ROC(ticker_all[,3])
#Initialise value for each stock series, with a total portfolio value
ticker_all$val1 = NA; ticker_all$val1[1] = 100
ticker_all$val2 = NA; ticker_all$val2[1] = 100
ticker_all$val3 = NA; ticker_all$val3[1] = 100
ticker_all$portfolio_val = NA
ticker_all$portfolio_val[1] = rowSums(ticker_all[1,8:10])
#Loop each row and 'compound'. Till it reaches the rebalancing date. Then reset stock value amount in that day. Take the portfolio value in t-1
for(i in 2:nrow(ticker_all)){
if(as.numeric(ticker_all$rebal[i]) == 0){
#During non-rebalancing days
ticker_all$val1[i] = as.numeric(ticker_all$val1[i-1]) * (1 + as.numeric(ticker_all$ret1[i]))
ticker_all$val2[i] = as.numeric(ticker_all$val2[i-1]) * (1 + as.numeric(ticker_all$ret2[i]))
ticker_all$val3[i] = as.numeric(ticker_all$val3[i-1]) * (1 + as.numeric(ticker_all$ret3[i]))
ticker_all$portfolio_val[i] = rowSums(ticker_all[i,8:10])
}else{
#During re-balancing days
ticker_all$val1[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$val2[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$val3[i] = ticker_all$portfolio_val[i-1] / 3
ticker_all$portfolio_val[i] = rowSums(ticker_all[i,8:10])
}
}
#Generate the daily portfolio returns
ticker_all$portfolio_ret = ROC(ticker_all[,11])
# rf = rf["2012/2018"]
######################################Study the portfolio returns########################################
#Carry out the portfolio return series
table.Drawdowns(ticker_all$portfolio_ret, top=10)
table.DownsideRisk(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
table.AnnualizedReturns(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
charts.PerformanceSummary(merge(ticker_all$portfolio_ret, ticker_all$ret1, ticker_all$ret2, ticker_all$ret3))
#####################################Study the annualized portfolio returns series#######################
#Use the rebal-indicator. Loop through the chunks
# https://www.quantmod.com/documentation/periodReturn.html
# https://rpubs.com/mohammadshadan/288218
# yearly_ret = periodReturn(ticker_all$portfolio_val
#              ,period='yearly',subset='2004::')  # returns years 2003 to present
yearly_ret = periodReturn(ticker_all$portfolio_val
,period='yearly')  # returns years 2003 to present
#Inefficient way to calulate standard deviation. If it've time, I will probably optimize this
split_val = split(ticker_all$portfolio_ret, f = "years")
yearly_ret$annual_sd = sapply(X = split_val, FUN = StdDev) * sqrt(252)
getSymbols('DGS3MO',src = 'FRED')
rf = DGS3MO; rm(DGS3MO)
rf = rf["2008/2018"]
split_val_rf = split(rf$DGS3MO, f = "years")
yearly_ret$annual_rf = sapply(X = split_val_rf, FUN = mean, na.rm = T)/100
yearly_ret$Sharpe = (yearly_ret$yearly.returns - yearly_ret$annual_rf)/yearly_ret$annual_sd
library(blogdown)
setwd("/home/jirong/Desktop/github/jirong-blog")
blogdown::serve_site()
